import numpy as np

# ===============================================================================================
# Padua Point Set Generation 
# ===============================================================================================

def padua_index_weights(n, 
                        edge_weight=1., 
                        vertex_weight=0.5,
                        interior_weight=2.):
    
    '''Return the pairs of indices (j,m) and their weight for each point in Padua set of order n
    Reference:
    
    Bos et. al. Bivariate Lagrange interpolation at the Padua points: the generating curve approach. (2006)
    
    '''
    
    dims = int(dims_padua_set(n))
    global_weight = (n * (n + 1.))
    
    #print("global weight", global_weight)
    

    vertex_0 = np.zeros((1, 3))
    vertex_0[:, 2] = vertex_weight * global_weight
    
    #print ("Vertext 0: ", vertex_weight * global_weight)

    vert_edge_m = None
    interior_indices = None
    if n > 1:
        vert_edge_m = np.zeros((n-1, 3))
        vert_edge_m[:, 1] = np.arange(1, n)
        vert_edge_m[:, 2] = edge_weight * global_weight
        
        #print ("vert_edge_m: ", edge_weight * global_weight)
        
        interior=[]
        for i in range(n):
            j = i + 1.0
            m_max = n - j 

            if m_max > 0 :
                for item in range(1, int(m_max + 1)):
                    interior.append([j, float(item)])
        
        interior_indices = np.zeros((len(interior), 3))
        interior_indices[:,0:2] = np.asarray(interior)
        interior_indices[:, 2] = interior_weight * global_weight
        
        #print ("interior_weight: ", interior_weight * global_weight)
    

    vertex_n = None
    hort_edge_j= None
    
    if n > 0:
        vertex_n = np.zeros((1, 3))
        vertex_n[0,1] = n
        vertex_n[0,2] = vertex_weight * global_weight
        
        #print ("interior_weight: ", vertex_weight * global_weight)

        hort_edge_j = np.zeros((n, 3))
        hort_edge_j[:, 0] = np.arange(1, n + 1)
        hort_edge_j[:, 2] = edge_weight * global_weight
        
        #print ("interior_weight: ", edge_weight * global_weight)

    index_set = np.vstack([vertex_0])
    for item in [vertex_n, vert_edge_m, hort_edge_j, interior_indices]:
        if item is not None:
            index_set = np.vstack([index_set, item])
    
    return index_set


def generating_curve(n, t):
    '''Return the x1 and x2 coordinates of the point x on a Padua generating curve of order n and angle t'''
    
    x1 = np.cos(n*t)
    x2 = np.cos((n + 1.)*t)
    return np.asarray([x1, x2])


def calc_padua_points(n):
    
    ''' 
    Return Pad_n, the set of Padua points on the square [-1,1]^2, and their weights
    
    Input:
    n - max degree of polynomial in space of polynomials of degree at most n in two variable    
    '''
    index_weights = padua_index_weights(n)
    pts = int(dims_padua_set(n))
    padua_points = np.zeros((pts, 2))
    
    if n > 0 :

        for idx_pt in range(pts):

            j, m  = index_weights[idx_pt, 0:2]
            arg = ((j * n) - m * (n + 1.) ) * np.pi / (n * (n + 1.))
            padua_points[idx_pt, :] = generating_curve(n, arg)
    
    return padua_points, index_weights[:, 2]

def transform_points(padua_points):
    '''
    Empirical plots show that Padua points generated by Bos et. al. in 2006
    correspond to a global -1.0 (rotation) and swapped x1, x2 coordinates (reflection).
    
    '''
    
    transformed_points = np.zeros_like(padua_points)
    transformed_points[:, 0] = -1.0 * padua_points[:, 1]
    transformed_points[:, 1] = -1.0 * padua_points[:, 0]
    
    return transformed_points

def dims_padua_set(n):
    '''Return the dimensions of the Padua set of order n'''
    
    return (n + 2.)*(n + 1.) / 2.

# ===============================================================================================
# Fundamental Lagrange Polynomial Calculations on Padua Point Set
# ===============================================================================================


def K_star(n, x, y):
    
    '''
    Reference:
    Bos et. al. IVARIATE LAGRANGE INTERPOLATION AT THE PADUA POINTS: THE IDEAL THEORY APPROACH (2006)
    '''
    ans = reproducing_kernel(n, x, y) - T_n(n, x[0])*T_n(n, y[0])
    
    return ans

def reproducing_kernel(n, A, B):
    ''' Return the reproducing kernel for the inner product defined on the space of polynomials on a square.
    
    Reference:
    Bos et. al. Bivariate Lagrange interpolation at the Padua points: the generating curve approach. (2006)
    In particular, refer Lemma 2 for the form of the reproducing kernel for any two points A, B on the square.
    '''
    
    theta1 = np.arccos(A[0])
    theta2 = np.arccos(A[1])
    phi1 = np.arccos(B[0])
    phi2 = np.arccos(B[1])
    
    ans=0.
    ans += D_operator(n, theta1 + phi1, theta2 + phi2)
    ans += D_operator(n, theta1 + phi1, theta2 - phi2)
    ans += D_operator(n, theta1 - phi1, theta2 + phi2)
    ans += D_operator(n, theta1 - phi1, theta2 - phi2)
    
    return ans

def D_operator(n, alpha, beta):
    
    '''Helper function for reproducing kernel function.
    
    Reference: Lemma 2 in
    Bos et. al. Bivariate Lagrange interpolation at the Padua points: the generating curve approach. (2004)
    '''
    
    numer = np.cos(alpha * (n + 0.5)) * np.cos(alpha *  0.5)
    numer += -1.0 * np.cos(beta * (n + 0.5)) * np.cos(beta *  0.5)
    
    denom = np.cos(alpha) - np.cos(beta)
    
    ans  = 0.5 * numer / denom
    
    #print("D operator", ans)
    
    if np.isnan(ans):
        
        if numer == 0. and denom == 0. :
            ans = 1.
            
            #print("D operator reset to", ans)
            
        if denom == 0. and numer != 0:
            print ("Ah fuck")
    
    return ans


def fundamental_L_B(n, X, B):
    ''' Return L_B(X), the coefficient for a fundamental Lagrange polynomial
    interpolant evalulated at padua point B for arbitrary point X. 
    
    The polynomials L_B are indeed the fundamental Lagrange polynomials,i.e., they satisfy
    L_B(A) = \delta_{A,B};  for A, B in Pad_n; and \Delta = 1 if A==B else 0
    
    Reference: 
    [1]Bos et. al. Bivariate Lagrange interpolation at the Padua points: the generating curve approach. (2006)
    [2] Bos et. al. BIVARIATE LAGRANGE INTERPOLATION AT THE PADUA POINTS: THE IDEAL THEORY APPROACH
    '''
       
    scalar_coeff_2 = K_star(n, X, B) / K_star(n, B, B)
    
    
    return scalar_coeff_2

def T_n(n, x_i):
    '''Chebyshev polynomial of the first kind of order n. Confirmed to be identifcal to Scipy.
    Reference:
    Bos et. al. IVARIATE LAGRANGE INTERPOLATION AT THE PADUA POINTS: THE IDEAL THEORY APPROACH (2006)
    '''
    
    theta = np.arccos(x_i)
    ans = np.cos(n * theta)
    
    return ans

def f_interpolant(n, x1, x2, padua_points, data_points):
    
    L_B_vector = np.asarray([ fundamental_L_B(1, [x1, x2], B) for B in padua_points])
    f_interpolant = np.sum(L_B_vector * data_points)    
    
    return f_interpolant